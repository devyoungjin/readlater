# 2장. 관계 데이터 모델

- [관계 데이터 모델의 개념](#01)
  - [릴레이션](#relation)
  - [릴레이션 개념(스키마/인스턴스)](#relation-definition)
  - [릴레이션 용어](#relation-term)
  - [특징](#relation-features)
  - [관계 데이터 모델](#relational-data-model)
- [키 (Key)](#02)
  - [슈퍼키](#super-key)
  - [후보키](#candidate-key)
  - [기본키](#primary-key)
  - [외래키](#foreign-key)
- [무결성 제약조건](#03)
  - [데이터 무결성 제약조건](#integrity-01)
  - [개체 무결성 제약조건](#integrity-02)
  - [참조 무결성 제약조건](#integrity-03)

## <a name="01">관계 데이터 모델의 개념</a>

### <a name="relation"></a>릴레이션 (Relation)

릴레이션은 행과 열로 구성된 테이블을 정의.

예를 들어 데이터가 아래와 같다고 가정해보자.

~~~json
{
   'name' : 'Youngjin Mo',
   'City' : 'Seoul',
   'Job' : 'Programmer'
},
{
   'name' : 'Leandro',
   'City' : 'Tokyo',
   'Job' : 'Athlete'
},
{
   'name' : 'Goeun Kim',
   'City' : 'LA',
   'Job' : 'Actress'
}
~~~

위의 데이터에서 서로 관계성이 높은 집합으로 데이터를 정리하면 아래처럼 정리할 수 있다.

~~~
name = {'Youngjin Mo', 'Leandro', 'Goeun Kim'}
city = {'Seoul', 'Tokyo', 'LA'}
job = {'Programmer', 'Athlete', 'Actress'}
~~~

이를 기반으로 <a name="sample-table"></a>테이블을 생성하면 아래처럼 생성할 수 있다.

|    Name     | City  |    Job     |
| :---------: | :---: | :--------: |
| Youngjin Mo | Seoul | Programmer |
|   Leandro   | Tokyo |  Athlete   |
|  Goeun Kim  |  LA   |  Actress   |

서로 연관된 데이터끼리 묶는다는 의미에서 수학적인 의미로 집합이라고 하며, 이를 <b>릴레이션</b>이라고 한다.

![릴레이션](http://www.mediafire.com/convkey/6642/w6yet8v1ozydrmxzg.jpg?size_id=a)

- **Relation (릴레이션)**
  - 개체를 표현하기 위한 데이터 구조
  - <mark>2차원 테이블</mark>
  - 스키마(head)와 본체(body)로 구성
    - 스키마는 attribute가 n개 모인 집합
    - 본체는 attribute의 집합인 tuple의 집합
- **Tuples (튜플)**
  - <mark>하나의 개체</mark>를 의미
  - <mark>속성(attribute)의 집합</mark>
  - Relation에서 행(Row)으로 표현
- **Attributes (속성)**
  - 개체의 속성들을 의미
  - Relation에서 열(Column)으로 표현

### <a name="relation-definition"></a>릴레이션의 두가지 개념

- 릴레이션 내 데이터들의 관계
  - 관련있는 실제 데이터들의 집합
  - 위의 [예제 테이블](#sample-table)에서 `name`, `city`, `job`으로 묶은것이 여기에 해당
- 릴레이션 간 관계
  - 릴레이션에서 다른 릴레이션으로 식별 가능한 값을 이용하여 연결.
  - 관계형 DB 개념을 의미하는것으로써 키(key)로 연결하는 작업이 여기에 해당 

릴레이션은 스키마와 인스턴스로 구분된다.

### 릴레이션 스키마 (Relation Schema)

- 릴레이션에 어떤 정보가 담길지를 정의.
- 각 열을 속성으로 정의.
- 용어
  - 속성(attibute) : 릴레이션 스키마의 열
  - 도메인(domain) : 속성이 가질 수 있는 값의 집합
  - 차수(degree) : 속성(attribute)의 갯수
    - 위의 [예제 테이블](#sample-table)에서 차수는 3이다.

### 릴레이션 인스턴스

- 릴레이션 <mark>스키마에 실제로 저장된 데이터의 집합</mark>
- 릴레이션의 한 행을 투플(tuple)이라 한다. 투플은 릴레이션 인스턴스의 각각의 행을 의미.
- 용어
  - 투플(tuple) : 릴레이션의 행
  - 카디날리티(cardinality) : 투플의 수
  - 위의 [예제 테이블](#sample-table)을 통해 개념 확인
    - 릴레이션은 3개의 투플로 구성되어 있다.
    - 첫번째 투플은 `name`이 `Youngjin Mo`, `city`가 `Seoul`, `job`이 `Programmer`이다.
    - 릴레이션의 카디날리티는 3이다.

### <a name="relation-term"></a>릴레이션 구조에 대한 용어

|  릴레이션 용어  | 같은 의미 용어  | 파일 시스템 용어 |
| :-------------: | :-------------: | :--------------: |
|    릴레이션     |     테이블      |    파일(file)    |
|     스키마      | 내포(intension) |   헤더(header)   |
|    인스턴스     | 외연(extension) |   데이터(data)   |
|   투플(tuple)   |     행(row)     |  레코드(record)  |
| 속성(attribute) |   열(column)    |   필드(field)    |

### <a name="relation-features"></a>릴레이션 특징

- 속성은 단일 값을 갖는다.
  - [예제 테이블](#sample-table) 기준으로 `name`은 하나의 값만 가져야한다.
- 속성은 서로 다른 이름을 갖는다.
  - [예제 테이블](#sample-table) 기준으로 속성 `name`, `job`, `city` 모두 다른 이름이다.
- 한 속성의 값은 모두 같은 도메인을 가진다.
  - `name`, `job`, `city`는 같은 도메인에 해당한다.
- 속성의 순서는 달라져도 상관없다.
  - `name` - `job` - `city` 대신 `job` - `city` - `name`으로 해도 달라진건 없다.
- 릴레이션내의 중복된 투플은 허용하지 않는다.
  - 테이블에 중복된 데이터를 허용할 경우 DBMS의 장점인 데이터 일관성을 유지할 수 없다.
- 투플의 순서는 상관없다.
  - 예제 테이블에서 `Goeun Kim`이 1번이 되든, `Leandro`가 1번이 되든 달라질건 없다.

### <a name="relational-data-model"></a>관계 데이터 모델 (Relational Data Model)

데이터를 2차원 테이블 형태인 릴레이션으로 표현하며 <mark>릴레이션에 대한 제약조건과 관계대수</mark>를 정의한 모델을 의미한다.

**제약조건**

각 릴레이션에 저장된 데이터 값이 가져야할 제약.

**관계연산**

릴레이션을 다루는 연산 규칙에 해당한다.

<a name="pettoy-table"></a>**PetToyShop**

| toy_id | product_name | qty  | price |
| :----: | :----------: | :--: | :---: |
|   1    | 물고기 인형  |  3   | 1000  |
|   2    |  당근 인형   |  4   | 2000  |
|   3    |  강아지 껌   |  2   | 3000  |

예를 들어 위의 테이블에서 구비된 상품들마다 전체 구입비용을 조회하려고 할 때 아래의 쿼리를 사용하는데 이런 연산 규칙이 관계 연산에 해당한다.

~~~sql
select qty*price from PetToyShop
~~~

## <a name="02">키</a>

### 키 (key)

<mark>특정 투플을 식별할때 사용하는 속성</mark> 또는 이러한 속성의 집합이다.

릴레이션간의 관계를 맺을때 사용된다. 키는 각 릴레이션의 투플을 유일하게 식별하는 역할을 한다. [PetToyShop 테이블](#pettoy-table)에서 `toy_id`가 릴레이션의 키가 될 수 있다.

키는 각각의 역할에 따라 아래의 키들로 분류할 수 있다.

<table>
  <tr>
  	<th style="width: 30%">키</th>
    <th>특징</th>
  </tr>
  <tr>
    <td><a href="#super-key">슈퍼키 (Super Key)</a></td>
    <td>투플을 유일하게 식별할 수 있는 속성</td>
  </tr>
  <tr>
    <td><a href="#candidate-key">후보키 (Candidate Key)</a></td>
    <td>투플을 유일하게 식별할 수 있는 속성의 최소한의 집합</td>
  </tr>
  <tr>
    <td><a href="#primary-key">기본키 (Primary Key)</a></td>
    <td>후보 키중 대표가 되는 키, 릴레이션을 대표하는 키</td>
  </tr>
  <tr>
    <td><a href="#artificial-key">대리키 (Artificial Key)</a></td>
    <td>후보키중 마땅한 기본키가 없을때 임의로 만드는 기본키</td>
  </tr>
  <tr>
    <td><a href="#alternate-key">대체키 (Alternate Key)</a></td>
    <td>기본키를 제외한 나머지 후보키</td>
  </tr>
  <tr>
    <td><a href="#foreign-key">외래키 (Foreign Key)</a></td>
    <td>다른 릴레이션의 기본키를 참조하는 속성 키</td>
  </tr>
</table>



### <a name="super-key"></a>슈퍼 키 (Super Key)

- 튜플을 유일하게(unique) 식별할 수 있는 하나의 속성 또는 이러한 속성의 집합
- 투플을 유일하게 식별가능한 값이면 모두 슈퍼 키가 될 수 있다.

사원번호, 주민등록번호 등이 유일한 특징을 가지므로 슈퍼키에 해당하는 조건을 가졌다고 볼 수 있다.

반면 주소와 이름 등은 유일하지 않은 특징이 있으므로 슈퍼키에 해당하지 않는다.

속성의 조합이 슈퍼키가 될 수 있는데 `{'주소', '이름', '주민번호'}`, `{'주소', '주민번호'}` 등이 이에 해당한다. 이런 키의 조합을 <b>복합키 (composite key)</b>라고 한다.

그러나 이런 조합을 사용할 경우 관계 표현이 복잡해질 수 있다. 따라서 슈퍼키는 unique한 특징을 가지면서 최소한의 조합일 때 좋은 슈퍼키가 될 수 있다.

### <a name="candidate-key"></a>후보 키 (Candidate Key)

- 슈퍼키중 투플을 유일하게 식별할 수 있는 <mark>최소한</mark>의 집합
- [기본키](#primary-key)의 후보

- 일반적으로 관계형 데이터베이스에서 키라고 하면, 후보 키를 의미한다.

`{'주민번호', '이름'}` 은 슈퍼키에 해당되지만, 후보키엔 해당될 수 없다. 최소성을 확보하지 못하기 때문이다. 가장 작은 슈퍼키인 `주민번호`가 존재하기 때문이다.

### <a name="primary-key"></a>기본 키 (Primary Key)

- 후보 키 중 대표가 되는 키
- 릴레이션을 대표하는 키

릴레이션을 대표하는 키이기 때문에 매우 중요하다. 기본키에서 문제가 발생할 경우 릴레이션간 관계에서도 문제가 발생할 수 있으므로 기본키 선정이 매우 중요하다고 볼 수 있다.

기본키 선정시 고려해야할 사항은 아래와 같다.

- 릴레이션내 투플을 식별가능한 고유한 값을 가져야 한다.
- NULL은 허용하지 않는다.
- 키 값에 변동이 발생하지 않아야한다.
- 최대한 적은 수의 속성을 가져야 한다.
- 향후 기본 키를 사용함에 있어 어떠한 문제도 발생해서는 안된다.

### <a name="artificial-key"></a>대리 키/인조 키 (Artificial Key)

- 마땅한 기본키가 없을때 가상의 속성을 만들어 기본키로 삼는 키

| 고객번호 | 도서번호 | 판매가격 |  주문일자  |
| :------: | :------: | :------: | :--------: |
|    1     |    1     |   7000   | 2014-07-01 |
|    1     |    2     |  13000   | 2014-07-03 |
|    2     |    5     |   8000   | 2014-07-03 |

위와 같은 릴레이션에서는 기본키(PK)로 사용할만한 마땅한 속성이 없으므로 임의의 속성을 만들어 기본키처럼 사용할 수 있다.

| 주문번호 | 고객번호 | 도서번호 | 판매가격 |  주문일자  |
| :------: | :------: | :------: | :------: | :--------: |
|    1     |    1     |    1     |   7000   | 2014-07-01 |
|    2     |    1     |    2     |  13000   | 2014-07-03 |
|    3     |    2     |    5     |   8000   | 2014-07-03 |

여기서 `주문번호`가 인조키에 해당한다.

### <a name="alternate-key"></a>대체 키 (Alternate Key)

- 기본키로 선정되지 않은 후보키.

후보키가 2개인데 하나가 기본키로 사용된다면, 나머지 하나는 대체키가 된다.

### <a name="foreign-key"></a>외래 키 (Foreign Key)

- 다른 릴레이션의 기본키를 참조하는 속성.

릴레이션간 관계를 표현하기 위한 중요한 속성이다.

아래 세가지 릴레이션이 있다. 이 릴레이션간의 관계를 통해 외래 키가 어떤 역할을 하는지 이해하자.

**고객**

| 고객번호 |  이름  |    주민번호    |      주소       |    핸드폰     |
| :------: | :----: | :------------: | :-------------: | :-----------: |
|    1     | 박지성 | 810101-1111111 |  영국 맨체스터  | 010-1234-5678 |
|    2     | 김연아 | 900101-2222222 |  대한민국 서울  | 010-2345-6789 |
|    3     | 장미란 | 830101-2222222 | 대한민국 강원도 | 010-3456-7891 |

**도서**

| 도서번호 |   도서이름    |   출판사   | 가격  |
| :------: | :-----------: | :--------: | :---: |
|    1     |  축구의 역사  |  굿스포츠  | 7000  |
|    2     | 축구아는 여자 |   나무수   | 13000 |
|    3     |  축구의 이해  | 대한미디어 | 22000 |

**주문**

| 주문번호 | 고객번호 | 도서번호 | 판매가격 |  주문일자  |
| :------: | :------: | :------: | :------: | :--------: |
|    1     |    1     |    1     |   7000   | 2014-07-01 |
|    2     |    1     |    2     |  13000   | 2014-07-02 |
|    3     |    2     |    5     |   8000   | 2014-07-03 |

위와 같은 릴레이션이 있을때 기본키는 각각의 테이블에서 가장 왼쪽에 있는 속성이 기본키가 될 수 있다.

**고객** 릴레이션에서는 `고객번호`, **도서** 릴레이션에서는 `도서번호`, **주문** 릴레이션에서는 `주문번호`.

**주문** 릴레이션에 있는 `고객번호`와 `도서번호`는 각각 <b>고객</b>, <b>도서</b> 릴레이션의 기본키와 동일한 속성이다. 따라서 이 후보키들은 <b>고객</b>, <b>도서</b> 릴레이션의 기본키를 참조해야 릴레이션간 관계에서 중복을 제거할 수 있다.

그래서 주문 릴레이션의 `고객번호`와 `도서번호`가 외래키에 해당하는 것이다.

**외래키의 조건**

- 양쪽 릴레이션의 도메인이 서로 같아야 한다.
- 릴레이션의 기본키 값이 변경되면, 해당 기본키를 참조하는 외래키의 값도 변경되어야 한다. 그래야 데이터의 일관성을 유지할 수 있다.

**외래키의 특징**

- 관계 데이터 모델의 <mark>릴레이션 간의 관계를 표현</mark>
- <mark>다른 릴레이션의 기본키를 참조</mark>하는 속성
- 참조하고(외래키) 참조되는 (기본키) 양쪽 릴레이션의 도메인은 서로 같다.
- 참조되는(기본키) 값이 변경되면 참조하는 (외래키) 값도 변경된다.
- NULL 값과 중복 값등이 허용된다.
- 자기 자신의 기본키를 참조하는 외래키도 가능
- 외래키가 기본키의 일부가 될 수 있다. 

<br>

##<a name="03">무결성 제약조건</a>

데이터 무결성(integrity)은 데이터베이스에 저장된 데이터의 일관성과 정확성을 지키는 것을 의미한다. 데이터 무결성을 유지하기 위해 필요한 제약조건은 아래와 같다.

- [데이터 무결성 제약조건](#integrity-01)
- [개체 무결성 제약조건](#integrity-02)
- [참조 무결성 제약조건](#integrity-03)

### <a name="integrity-01"></a>도메인 무결성 제약조건 (Domain Integrity Constraint)

- 속성값과 관련된 무결성 조건을 의미한다.
- 릴레이션내 투플들이 각 속성의 도메인에 지정된 값만을 가져야 한다는 조건이다.
  - 예) 주문 릴레이션에서 주문일자는 날짜 데이터만 사용한다.
  - 예) `영문명` 이라는 속성에는 영어로된 값이 들어가야 의도대로 조회가 가능하다.
- SQL 문에서 데이터 타입(`varchar`), 널 허용여부(`NULL`, `NOT NULL`), 기본 값(default) 등으로 지정할 수 있다.

### <a name="integrity-02"></a>개체 무결성 제약조건 (Entity Integrity Constraint)

- <mark><u>기본키</u></mark> 제약조건이다.
- 릴레이션은 기본키를 지정하고 그에 따른 무결성 원칙을 준수해야 한다.
- <mark>기본키는 NULL 값을 가져서는 안되고, 릴레이션 내에 오직 하나의 값만 존재</mark>해야 한다.
- 개체 무결성 제약조건은 참조 무결성 제약조건과 함께 관계 데이터 모델의 핵심 개념이다.

### <a name="integrity-03"></a>참조 무결성 제약조건 (Referential Integrity Constraint)

- <mark><u>외래키</u></mark> 제약조건이다.
- <mark>릴레이션 간의 참조 관계를 선언하는 제약조건</mark>이다.
- 참조되는 릴레이션이 부모 릴레이션, 참조하는 릴레이션을 자식 릴레이션이라 한다.
- 자식 릴레이션의 외래키는 부모 릴레이션의 기본키와 도메인이 동일해야 한다.
- 자식 릴레이션의 값이 변경될때, 부모 릴레이션의 제약조건을 따른다.
  - 부모 릴레이션의 속성 타입이 아닌 값을 자식 릴레이션에서 INSERT 하는 일은 불가능
  - 자식 릴레이션에서 참조하는 값을 부모 릴레이션에서 UPDATE/DELETE하는 일도 불가능

<br>

### 참조 무결성 제약조건의 옵션 (부모 릴레이션에서 투플을 삭제할 경우)

![예제 테이블](https://user-images.githubusercontent.com/33862991/124860708-19524f80-dfed-11eb-9dd9-45ba7efff95f.png)

<style>
  table tr th {
     text-align: center;
  }
</style>
<table>
  <tr>
  	<th>명령어</th>
    <th>의미</th>
    <th>예</th>
  </tr>
  <tr>
  	<td style="text-align: center">RESTRICTED</td>
    <td>자식 릴레이션에서 참조할 경우 부모 릴레이션의 삭제 작업을 거부</td>
    <td>학과 릴레이션의 투플 삭제 거부</td>
  </tr>
  <tr>
  	<td style="text-align: center">CASCADE</td>
    <td>자식 릴레이션의 관련 투플을 같이 삭제</td>
    <td>학생 릴레이션의 관련 투플을 삭제</td>
  </tr>
  <tr>
  	<td style="text-align: center">DEFAULT</td>
    <td>자식 릴레이션의 관련 투플을 미리 설정해둔 값으로 변경</td>
    <td>학생 릴레이션의 학과가 다른 학과로 자동 배정</td>
  </tr>
  <tr>
  	<td style="text-align: center">NULL</td>
    <td>자식 릴레이션의 관련 투플을 NULL 값으로 설정함 (NULL 값을 허가한 경우)</td>
    <td>학생 릴레이션의 학과가 NULL 값으로 변경</td>
  </tr>
</table>


